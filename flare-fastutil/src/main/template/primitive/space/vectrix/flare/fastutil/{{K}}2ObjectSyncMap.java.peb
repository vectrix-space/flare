package space.vectrix.flare.fastutil;

import it.unimi.dsi.fastutil.{{ G }}.{{ K }}2ObjectMap;
import it.unimi.dsi.fastutil.{{ G }}.{{ K }}2ObjectOpenHashMap;
import it.unimi.dsi.fastutil.{{ G }}.{{ K }}Set;
import it.unimi.dsi.fastutil.objects.ObjectSet;
import java.util.Collections;
import java.util.Map;
import java.util.function.BiFunction;
import java.util.function.IntFunction;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

/**
 * A concurrent map, internally backed by a non-thread-safe map but carefully
 * managed in a matter such that any changes are thread-safe. Internally, the
 * map is split into an {@code immutable} and {@code mutable} map. The
 * immutable map only satisfies read requests, while the mutable map satisfies
 * all other requests.
 *
 * <p>The map is optimized for two common use cases:</p>
 *
 * <ul>
 *     <li>The entry for the given map is only written once but read many
 *         times, as in a cache that only grows.</li>
 *
 *     <li>Heavy concurrent modification of entries over a disjoint set of
 *         keys.</li>
 * </ul>
 *
 * <p>In both cases, this map significantly reduces lock contention compared
 * to a traditional map paired with a read and write lock, along with maps
 * with an exclusive lock (such as using
 * {@link Collections#synchronizedMap(Map)}).</p>
 *
 * <p>Null values are not accepted.</p>
 *
 * <p>Based on: <a href="https://go.dev/src/sync/map.go">sync/map.go</a></p>
 *
 * @param <V> the value type
 * @since 0.2.0
 */
public interface {{ K }}2ObjectSyncMap<V> extends {{ K }}2ObjectMap<V> {
  /**
   * Returns a new sync map, backed by a {@link {{ K }}2ObjectOpenHashMap}.
   *
   * @param <V> the value type
   * @return a sync map
   * @since 0.2.0
   */
  @SuppressWarnings("RedundantTypeArguments")
  static <V> @NotNull {{ K }}2ObjectSyncMap<V> hashmap() {
    return of({{ K }}2ObjectOpenHashMap<{{ K }}2ObjectExpungingValue<V>>::new, 16);
  }

  /**
   * Returns a new sync map, backed by a {@link {{ K }}2ObjectOpenHashMap} with a provided
   * initial capacity.
   *
   * @param initialCapacity the initial capacity of the hash map
   * @param <V> the value type
   * @return a sync map
   * @since 0.2.0
   */
  @SuppressWarnings("RedundantTypeArguments")
  static <V> @NotNull {{ K }}2ObjectSyncMap<V> hashmap(final int initialCapacity) {
    return of({{ K }}2ObjectOpenHashMap<{{ K }}2ObjectExpungingValue<V>>::new, initialCapacity);
  }

  /**
   * Returns a new mutable set view of a sync map, backed by a {@link {{ K }}2ObjectOpenHashMap}.
   *
   * @return a mutable set view of a sync map
   * @since 0.2.0
   */
  @SuppressWarnings("RedundantTypeArguments")
  static @NotNull {{ K }}Set hashset() {
    return ofSet({{ K }}2ObjectOpenHashMap<{{ K }}2ObjectExpungingValue<Boolean>>::new, 16);
  }

  /**
   * Returns a new mutable set view of a sync map, backed by a {@link {{ K }}2ObjectOpenHashMap}
   * with a provided initial capacity.
   *
   * @param initialCapacity the initial capacity of the hash map
   * @return a mutable set view of a sync map
   * @since 0.2.0
   */
  @SuppressWarnings("RedundantTypeArguments")
  static @NotNull {{ K }}Set hashset(final int initialCapacity) {
    return ofSet({{ K }}2ObjectOpenHashMap<{{ K }}2ObjectExpungingValue<Boolean>>::new, initialCapacity);
  }

  /**
   * Returns a new sync map, backed by the provided {@link {{ K }}2ObjectMap} implementation
   * with a provided initial capacity.
   *
   * @param function the map creation function
   * @param initialCapacity the map initial capacity
   * @param <V> the value type
   * @return a sync map
   * @since 0.2.0
   */
  static <V> @NotNull {{ K }}2ObjectSyncMap<V> of(final @NotNull IntFunction<{{ K }}2ObjectMap<{{ K }}2ObjectExpungingValue<V>>> function, final int initialCapacity) {
    return new {{ K }}2ObjectSyncMapImpl<>(function, initialCapacity);
  }

  /**
   * Returns a new mutable set view of a sync map, backed by the provided
   * {@link {{ K }}2ObjectMap} implementation with a provided initial capacity.
   *
   * @param function the map creation function
   * @param initialCapacity the map initial capacity
   * @return a mutable set view of a sync map
   * @since 3.0.0
   */
  static @NotNull {{ K }}Set ofSet(final @NotNull IntFunction<{{ K }}2ObjectMap<{{ K }}2ObjectExpungingValue<Boolean>>> function, final int initialCapacity) {
    return new {{ K }}2ObjectSyncMapSet(new {{ K }}2ObjectSyncMapImpl<>(function, initialCapacity));
  }

  /**
   * {@inheritDoc}
   *
   * <p>This implementation is {@code O(n)} in nature due to the need to check
   * for any expunged entries. Likewise, as with other concurrent collections,
   * the value obtained by this method may be out of date by the time this
   * method returns.</p>
   *
   * @return the size of all the mappings contained in this map
   */
  @Override
  int size();

  /**
   * {@inheritDoc}
   *
   * <p>The remapping function may be called more than once to avoid locking if
   * it is not necessary.</p>
   *
   * @param key key with which the specified value is to be associated
   * @param remappingFunction the remapping function to compute a value
   * @return the new value associated with the specified key, or null if none
   */
  @Override
  @Nullable V computeIfPresent(final {{ k }} key, final @NotNull BiFunction<? super {{ KT }}, ? super V, ? extends V> remappingFunction);

  /**
   * {@inheritDoc}
   *
   * <p>The remapping function may be called more than once to avoid locking if
   * it is not necessary.</p>
   *
   * @param key key with which the specified value is to be associated
   * @param remappingFunction the remapping function to compute a value
   * @return the new value associated with the specified key, or null if none
   */
  @Override
  @Nullable V compute(final {{ k }} key, final @NotNull BiFunction<? super {{ KT }}, ? super V, ? extends V> remappingFunction);

  /**
   * {@inheritDoc}
   *
   * <p>This method clears the map by resetting the internal state to a state
   * similar to as if a new map had been created. If there are concurrent
   * iterations in progress, they will reflect the state of the map prior to
   * being cleared.</p>
   */
  @Override
  void clear();

  /**
   * {@inheritDoc}
   *
   * <p>Iterations over a sync map are thread-safe, and the keys iterated over
   * will not change for a single iteration attempt, however they may not
   * necessarily reflect the state of the map at the time the iterator was
   * created.</p>
   *
   * <p>Performance Note: If entries have been appended to the map, iterating
   * over the entry set will automatically promote them to the read map.</p>
   */
  @Override
  @NotNull ObjectSet<Entry<V>> {{ k }}2ObjectEntrySet();

  /**
   * The expunging entry the backing map wraps for its values.
   *
   * @param <V> the value type
   * @since 2.0.0
   */
  interface {{ K }}2ObjectExpungingValue<V> extends ExpungingValue<V> {
    /**
     * Attempts to compute the value in the provided {@link BiFunction} and
     * store it returning the next value and the
     * {@link ExpungingValue.Operation}.
     *
     * @param key the key
     * @param remappingFunction the remapping function
     * @return the next value or null and the operation
     * @since 3.0.0
     */
    Map.@NotNull Entry<V, ExpungingValue.Operation> compute(final {{ k }} key, final @NotNull BiFunction<? super {{ KT }}, ? super V, ? extends V> remappingFunction);

    /**
     * Attempts to compute the value in the provided {@link BiFunction} and
     * store it if the value is not expunged returning the next value and
     * the {@link ExpungingValue.Operation}.
     *
     * @param key the key
     * @param remappingFunction the remapping function
     * @return the next value or null and the operation
     * @since 3.0.0
     */
    Map.@NotNull Entry<V, ExpungingValue.Operation> computePresent(final {{ k }} key, final @NotNull BiFunction<? super {{ KT }}, ? super V, ? extends V> remappingFunction);
  }
}
