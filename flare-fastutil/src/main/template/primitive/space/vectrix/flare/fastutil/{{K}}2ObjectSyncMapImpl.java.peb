package space.vectrix.flare.fastutil;

import it.unimi.dsi.fastutil.{{ G }}.Abstract{{ K }}2ObjectMap;
import it.unimi.dsi.fastutil.{{ G }}.{{ K }}2ObjectFunction;
import it.unimi.dsi.fastutil.{{ G }}.{{ K }}2ObjectMap;
import it.unimi.dsi.fastutil.objects.AbstractObjectSet;
import it.unimi.dsi.fastutil.objects.ObjectIterator;
import it.unimi.dsi.fastutil.objects.ObjectSet;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Objects;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.IntFunction;
import java.util.function.{{ KA }}Function;

import static java.util.Objects.requireNonNull;

/* package */ final class {{ K }}2ObjectSyncMapImpl<V> extends Abstract{{ K }}2ObjectMap<V> implements {{ K }}2ObjectSyncMap<V> {
  private static final long serialVersionUID = 1;
  private transient final Object lock = new Object();
  private transient final IntFunction<{{ K }}2ObjectMap<{{ K }}2ObjectExpungingValue<V>>> function;
  private transient volatile {{ K }}2ObjectMap<{{ K }}2ObjectExpungingValue<V>> immutable;
  private transient volatile boolean amended;
  private transient {{ K }}2ObjectMap<{{ K }}2ObjectExpungingValue<V>> mutable;
  private transient int misses;
  private transient EntrySet entrySet;

  /* package */ {{ K }}2ObjectSyncMapImpl(final @NotNull IntFunction<{{ K }}2ObjectMap<{{ K }}2ObjectExpungingValue<V>>> function, final int initialCapacity) {
    if(initialCapacity < 0) throw new IllegalArgumentException("Initial capacity must be greater than 0");
    this.function = function;
    this.immutable = function.apply(initialCapacity);
  }

  // Query Operations

  @Override
  public int size() {
    final {{ K }}2ObjectMap<{{ K }}2ObjectExpungingValue<V>> immutable = this.promote();
    int size = 0;
    for(final {{ K }}2ObjectExpungingValue<V> value : immutable.values()) {
      if(!value.empty()) size++;
    }
    return size;
  }

  @Override
  public boolean isEmpty() {
    final {{ K }}2ObjectMap<{{ K }}2ObjectExpungingValue<V>> immutable = this.promote();
    for(final {{ K }}2ObjectExpungingValue<V> value : immutable.values()) {
      if(!value.empty()) return false;
    }
    return true;
  }

  @Override
  public boolean containsValue(final @Nullable Object value) {
    for(final {{ K }}2ObjectMap.Entry<V> entry : this.{{ k }}2ObjectEntrySet()) {
      if(Objects.equals(entry.getValue(), value)) return true;
    }
    return false;
  }

  @Override
  public boolean containsKey(final {{ k }} key) {
    final {{ K }}2ObjectExpungingValue<V> value = this.getValue(key);
    return value != null && !value.empty();
  }

  @Override
  public @Nullable V get(final {{ k }} key) {
    final {{ K }}2ObjectExpungingValue<V> value = this.getValue(key);
    return value != null ? value.get() : null;
  }

  @Override
  public @NotNull V getOrDefault(final {{ k }} key, final @NotNull V defaultValue) {
    requireNonNull(defaultValue, "defaultValue");
    final {{ K }}2ObjectExpungingValue<V> value = this.getValue(key);
    return value != null ? value.getOrDefault(defaultValue) : defaultValue;
  }

  private @Nullable {{ K }}2ObjectSyncMap.{{ K }}2ObjectExpungingValue<V> getValue(final {{ k }} key) {
    {{ K }}2ObjectExpungingValue<V> entry = this.immutable.get(key);
    if(entry != null) return entry;
    if(this.amended) {
      // Check if the map is amended to access an entry from the mutable map.
      synchronized(this.lock) {
        if((entry = this.immutable.get(key)) == null && this.amended) {
          entry = this.mutable.get(key);
          // Count a miss to avoid taking this slow path in the future.
          this.lockedMiss();
        }
      }
    }
    return entry;
  }

  @Override
  public @Nullable V computeIfAbsent(final {{ k }} key, final @NotNull {{ KA }}Function<? extends V> mappingFunction) {
    requireNonNull(mappingFunction, "mappingFunction");
    // Compute the mapping function ahead of time, so we
    // can exit early if the computed value is null or
    // throws an exception.
    final V newValue = mappingFunction.apply(key);
    if(newValue == null) return null;
    {{ K }}2ObjectExpungingValue<V> entry = this.immutable.get(key);
    Map.Entry<V, ExpungingValue.Operation> result = entry != null ? entry.updateAbsent(null, newValue) : null;
    if(result != null && result.getValue() != ExpungingValue.Operation.EXPUNGED) return result.getKey();
    synchronized(this.lock) {
      if((entry = this.immutable.get(key)) != null) {
        // Unexpunge the entry. If modified add back
        // to the mutable map.
        if(entry.unexpunge(newValue)) {
          this.mutable.put(key, entry);
          return newValue;
        }
        // Otherwise force set the value onto the entry.
        result = entry.forceUpdateAbsent(null, newValue);
      } else if(this.amended && (entry = this.mutable.get(key)) != null) {
        result = entry.forceUpdateAbsent(null, newValue);
        // The slow path should be avoided, even if the value does
        // not match or is present. So we mark a miss, to eventually
        // promote and take a faster path.
        this.lockedMiss();
      } else {
        if(!this.amended) {
          // Adds the first new key to the mutable map and marks it as
          // amended.
          this.lockedDirty();
        }
        this.mutable.put(key, new {{ K }}2ObjectExpungingValueImpl<>(newValue));
        return newValue;
      }
    }
    return result.getValue() != ExpungingValue.Operation.EXPUNGED ? result.getKey() : null;
  }

  @Override
  public @Nullable V computeIfAbsent(final {{ k }} key, final @NotNull {{ K }}2ObjectFunction<? extends V> mappingFunction) {
    requireNonNull(mappingFunction, "mappingFunction");
    // Compute the mapping function ahead of time, so we
    // can exit early if the computed value is null or
    // throws an exception.
    final V defaultValue = mappingFunction.defaultReturnValue();
    final V newValue = mappingFunction.get(key);
    if(newValue == null || !mappingFunction.containsKey(key)) return defaultValue;
    {{ K }}2ObjectExpungingValue<V> entry = this.immutable.get(key);
    Map.Entry<V, ExpungingValue.Operation> result = entry != null ? entry.updateAbsent(null, newValue) : null;
    if(result != null && result.getValue() != ExpungingValue.Operation.EXPUNGED) return result.getKey();
    synchronized(this.lock) {
      if((entry = this.immutable.get(key)) != null) {
        // Unexpunge the entry. If modified add back
        // to the mutable map.
        if(entry.unexpunge(newValue)) {
          this.mutable.put(key, entry);
          return newValue;
        }
        // Otherwise force set the value onto the entry.
        result = entry.forceUpdateAbsent(null, newValue);
      } else if(this.amended && (entry = this.mutable.get(key)) != null) {
        result = entry.forceUpdateAbsent(null, newValue);
        // The slow path should be avoided, even if the value does
        // not match or is present. So we mark a miss, to eventually
        // promote and take a faster path.
        this.lockedMiss();
      } else {
        if(!this.amended) {
          // Adds the first new key to the mutable map and marks it as
          // amended.
          this.lockedDirty();
        }
        this.mutable.put(key, new {{ K }}2ObjectExpungingValueImpl<>(newValue));
        return newValue;
      }
    }
    return result.getValue() != ExpungingValue.Operation.EXPUNGED ? result.getKey() : defaultValue;
  }

  @Override
  public @Nullable V computeIfPresent(final {{ k }} key, final @NotNull BiFunction<? super {{ KT }}, ? super V, ? extends V> remappingFunction) {
    requireNonNull(remappingFunction, "remappingFunction");
    {{ K }}2ObjectExpungingValue<V> entry = this.immutable.get(key);
    final Map.Entry<V, ExpungingValue.Operation> result = entry != null ? entry.computePresent(key, remappingFunction) : null;
    if(result != null && result.getValue() != ExpungingValue.Operation.EXPUNGED) return result.getKey();
    V previous, next = null;
    synchronized(this.lock) {
      if((entry = this.immutable.get(key)) != null) {
        // If the entry value does not exist, return null,
        // otherwise force set the value onto the entry.
        if((previous = entry.get()) == null) return null;
        entry.forceUpdate(previous, next = remappingFunction.apply(key, previous));
      } else if(this.amended && (entry = this.mutable.get(key)) != null) {
        if((previous = entry.get()) == null) return null;
        entry.forceUpdate(previous, next = remappingFunction.apply(key, previous));
        // The slow path should be avoided, even if the value does
        // not match or is present. So we mark a miss, to eventually
        // promote and take a faster path.
        this.lockedMiss();
      }
    }
    return next;
  }

  @Override
  public @Nullable V compute(final {{ k }} key, final @NotNull BiFunction<? super {{ KT }}, ? super V, ? extends V> remappingFunction) {
    requireNonNull(remappingFunction, "remappingFunction");
    {{ K }}2ObjectExpungingValue<V> entry = this.immutable.get(key);
    final Map.Entry<V, ExpungingValue.Operation> result = entry != null ? entry.compute(key, remappingFunction) : null;
    if(result != null && result.getValue() != ExpungingValue.Operation.EXPUNGED) return result.getKey();
    final V next;
    synchronized(this.lock) {
      if((entry = this.immutable.get(key)) != null) {
        next = remappingFunction.apply(key, entry.get());
        // If the entry was expunged, unexpunge, add the entry
        // back to the mutable map, if the value exists.
        if(entry.unexpunge(next)) {
          if(next != null) this.mutable.put(key, entry);
          return next;
        }
        // Otherwise force set the value onto the entry.
        entry.forceSet(next);
      } else if(this.amended && (entry = this.mutable.get(key)) != null) {
        next = remappingFunction.apply(key, entry.get());
        // If the value does not exist, remove it from the
        // mutable map and force set the next value.
        if(next == null) this.mutable.remove(key);
        entry.forceSet(next);
        // The slow path should be avoided, even if the value does
        // not match or is present. So we mark a miss, to eventually
        // promote and take a faster path.
        this.lockedMiss();
      } else {
        if(!this.amended) {
          // Adds the first new key to the mutable map and marks it as
          // amended.
          this.lockedDirty();
        }
        next = remappingFunction.apply(key, null);
        if(next != null) this.mutable.put(key, new {{ K }}2ObjectExpungingValueImpl<>(next));
      }
    }
    return next;
  }

  @Override
  public @Nullable V putIfAbsent(final {{ k }} key, final @NotNull V value) {
    requireNonNull(value, "value");
    {{ K }}2ObjectExpungingValue<V> entry = this.immutable.get(key);
    Map.Entry<V, ExpungingValue.Operation> result = entry != null ? entry.update(null, value) : null;
    if(result != null && result.getValue() != ExpungingValue.Operation.EXPUNGED) return result.getKey();
    synchronized(this.lock) {
      if((entry = this.immutable.get(key)) != null) {
        // Unexpunge the entry. If modified add back
        // to the mutable map.
        if(entry.unexpunge(value)) {
          this.mutable.put(key, entry);
          return null;
        }
        // Otherwise force set the value onto the entry.
        result = entry.forceUpdate(null, value);
      } else if(this.amended && (entry = this.mutable.get(key)) != null) {
        result = entry.forceUpdate(null, value);
        // The slow path should be avoided, even if the value does
        // not match or is present. So we mark a miss, to eventually
        // promote and take a faster path.
        this.lockedMiss();
      } else {
        if(!this.amended) {
          // Adds the first new key to the mutable map and marks it as
          // amended.
          this.lockedDirty();
        }
        this.mutable.put(key, new {{ K }}2ObjectExpungingValueImpl<>(value));
        return null;
      }
    }
    return result.getKey();
  }

  @Override
  public @Nullable V put(final {{ k }} key, final @NotNull V value) {
    requireNonNull(value, "value");
    {{ K }}2ObjectExpungingValue<V> entry = this.immutable.get(key);
    Map.Entry<V, ExpungingValue.Operation> result = entry != null ? entry.set(value) : null;
    if(result != null && result.getValue() != ExpungingValue.Operation.EXPUNGED) return result.getKey();
    final V previousValue;
    synchronized(this.lock) {
      if((entry = this.immutable.get(key)) != null) {
        // Unexpunge the entry. If modified add back
        // to the mutable map.
        if(entry.unexpunge(value)) {
          this.mutable.put(key, entry);
          return null;
        }
        // Otherwise force set the value onto the entry.
        previousValue = entry.get();
        entry.forceSet(value);
      } else if(this.amended && (entry = this.mutable.get(key)) != null) {
        previousValue = entry.get();
        entry.forceSet(value);
        // The slow path should be avoided, even if the value does
        // not match or is present. So we mark a miss, to eventually
        // promote and take a faster path.
        this.lockedMiss();
      } else {
        if(!this.amended) {
          // Adds the first new key to the mutable map and marks it as
          // amended.
          this.lockedDirty();
        }
        this.mutable.put(key, new {{ K }}2ObjectExpungingValueImpl<>(value));
        return null;
      }
    }
    return previousValue;
  }

  @Override
  public @Nullable V remove(final {{ k }} key) {
    {{ K }}2ObjectExpungingValue<V> entry = this.immutable.get(key);
    if(entry == null && this.amended) {
      synchronized(this.lock) {
        if((entry = this.immutable.get(key)) == null && this.amended) {
          entry = this.mutable.remove(key);
          // The slow path should be avoided, even if the value does
          // not match or is present. So we mark a miss, to eventually
          // promote and take a faster path.
          this.lockedMiss();
        }
      }
    }
    return entry != null ? entry.clear() : null;
  }

  @Override
  public boolean remove(final {{ k }} key, final @NotNull Object value) {
    requireNonNull(value, "value");
    {{ K }}2ObjectExpungingValue<V> entry = this.immutable.get(key);
    if(entry == null && this.amended) {
      synchronized(this.lock) {
        if((entry = this.immutable.get(key)) == null && this.amended) {
          final boolean removed = ((entry = this.mutable.get(key)) != null && entry.update(value, null).getValue() == ExpungingValue.Operation.MODIFIED);
          if(removed) this.mutable.remove(key);
          // The slow path should be avoided, even if the value does
          // not match or is present. So we mark a miss, to eventually
          // promote and take a faster path.
          this.lockedMiss();
          return removed;
        }
      }
    }
    return entry != null && entry.update(value, null).getValue() == ExpungingValue.Operation.MODIFIED;
  }

  @Override
  public @Nullable V replace(final {{ k }} key, final @NotNull V value) {
    requireNonNull(value, "value");
    {{ K }}2ObjectExpungingValue<V> entry = this.immutable.get(key);
    Map.Entry<V, ExpungingValue.Operation> result = entry != null ? entry.set(value) : null;
    if(result != null && result.getValue() != ExpungingValue.Operation.EXPUNGED) return result.getKey();
    V previousValue = null;
    if(this.amended) {
      synchronized(this.lock) {
        if((entry = this.immutable.get(key)) != null) {
          previousValue = entry.get();
          entry.forceSet(value);
        } else if(this.amended && (entry = this.mutable.get(key)) != null) {
          previousValue = entry.get();
          entry.forceSet(value);
          // The slow path should be avoided, even if the value does
          // not match or is present. So we mark a miss, to eventually
          // promote and take a faster path.
          this.lockedMiss();
        }
      }
    }
    return previousValue;
  }

  @Override
  public boolean replace(final {{ k }} key, final @NotNull V oldValue, final @NotNull V newValue) {
    requireNonNull(oldValue, "oldValue");
    requireNonNull(newValue, "newValue");
    {{ K }}2ObjectExpungingValue<V> entry = this.immutable.get(key);
    Map.Entry<V, ExpungingValue.Operation> result = entry != null ? entry.update(oldValue, newValue) : null;
    if(result != null && result.getValue() == ExpungingValue.Operation.MODIFIED) return true;
    if(this.amended) {
      synchronized(this.lock) {
        if((entry = this.immutable.get(key)) != null) {
          result = entry.forceUpdate(oldValue, newValue);
        } else if(this.amended && (entry = this.mutable.get(key)) != null) {
          result = entry.forceUpdate(oldValue, newValue);
          // The slow path should be avoided, even if the value does
          // not match or is present. So we mark a miss, to eventually
          // promote and take a faster path.
          this.lockedMiss();
        }
      }
    }
    return result != null && result.getValue() == ExpungingValue.Operation.MODIFIED;
  }

  // Bulk Operations

  @Override
  public void forEach(final @NotNull BiConsumer<? super {{ KT }}, ? super V> action) {
    requireNonNull(action, "action");
    final {{ K }}2ObjectMap<{{ K }}2ObjectExpungingValue<V>> immutable = this.promote();
    V value;
    for(final {{ K }}2ObjectMap.Entry<{{ K }}2ObjectExpungingValue<V>> that : immutable.{{ k }}2ObjectEntrySet()) {
      if((value = that.getValue().get()) != null) {
        action.accept(that.get{{ K }}Key(), value);
      }
    }
  }

  @Override
  public void replaceAll(final @NotNull BiFunction<? super {{ KT }}, ? super V, ? extends V> function) {
    requireNonNull(function, "function");
    final {{ K }}2ObjectMap<{{ K }}2ObjectExpungingValue<V>> immutable = this.promote();
    for(final {{ K }}2ObjectMap.Entry<{{ K }}2ObjectExpungingValue<V>> that : immutable.{{ k }}2ObjectEntrySet()) {
      final {{ k }} key = that.get{{ K }}Key();
      final V previous;
      {{ K }}2ObjectExpungingValue<V> entry = that.getValue();
      Map.Entry<V, ExpungingValue.Operation> result = entry != null ? entry.compute(key, function) : null;
      if(result == null && this.amended) {
        synchronized(this.lock) {
          if((entry = this.immutable.get(key)) != null) {
            if((previous = entry.get()) == null) continue;
            entry.forceUpdate(previous, function.apply(key, previous));
          } else if(this.amended && (entry = this.mutable.get(key)) != null) {
            if((previous = entry.get()) == null) continue;
            entry.forceUpdate(previous, function.apply(key, previous));
            // The slow path should be avoided, even if the value does
            // not match or is present. So we mark a miss, to eventually
            // promote and take a faster path.
            this.lockedMiss();
          }
        }
      }
    }
  }

  @Override
  public void clear() {
    synchronized(this.lock) {
      this.amended = false;
      this.immutable = this.function.apply(this.immutable.size());
      this.mutable = null;
      this.misses = 0;
    }
  }

  // Views

  @Override
  public @NotNull ObjectSet<Entry<V>> {{ k }}2ObjectEntrySet() {
    if(this.entrySet != null) return this.entrySet;
    return this.entrySet = new EntrySet();
  }

  private {{ K }}2ObjectMap<{{ K }}2ObjectExpungingValue<V>> promote() {
    {{ K }}2ObjectMap<{{ K }}2ObjectExpungingValue<V>> map = this.immutable;
    if(this.amended) {
      synchronized(this.lock) {
        if(this.amended) {
          this.lockedPromote();
          map = this.immutable;
        }
      }
    }
    return map;
  }

  private void lockedMiss() {
    if(++this.misses < this.mutable.size()) return;
    this.lockedPromote();
  }

  private void lockedPromote() {
    this.amended = false;
    this.immutable = this.mutable;
    this.mutable = null;
    this.misses = 0;
  }

  private void lockedDirty() {
    this.mutable = this.function.apply(this.immutable.size() + 1);
    this.immutable.{{ k }}2ObjectEntrySet().forEach(entry -> {
      if(!entry.getValue().expunge()) this.mutable.put(entry.get{{ K }}Key(), entry.getValue());
    });
    this.amended = true;
  }

  /* package */ final class EntryImpl implements {{ K }}2ObjectMap.Entry<V> {
    private final {{ k }} key;

    /* package */ EntryImpl(final {{ k }} key) {
      this.key = key;
    }


    @Override
    public {{ k }} get{{ K }}Key() {
      return this.key;
    }

    @Override
    public @Nullable V getValue() {
      return {{ K }}2ObjectSyncMapImpl.this.get(this.key);
    }

    @Override
    public @Nullable V setValue(final @NotNull V value) {
      return {{ K }}2ObjectSyncMapImpl.this.replace(this.key, value);
    }

    @Override
    public int hashCode() {
      return Objects.hash(this.get{{ K }}Key(), this.getValue());
    }

    @Override
    public boolean equals(final @Nullable Object other) {
      if(this == other) return true;
      if(!(other instanceof Map.Entry)) return false;
      final Map.Entry<?, ?> that = (Map.Entry<?, ?>) other;
      return Objects.equals(this.get{{ K }}Key(), that.getKey())
        && Objects.equals(this.getValue(), that.getValue());
    }

    @Override
    public String toString() {
      return "EntryImpl{key=" + this.get{{ K }}Key() + ", value=" + this.getValue() + "}";
    }
  }

  /* package */ final class EntrySet extends AbstractObjectSet<{{ K }}2ObjectMap.Entry<V>> {
    @Override
    public int size() {
      return {{ K }}2ObjectSyncMapImpl.this.size();
    }

    @Override
    @SuppressWarnings("deprecation")
    public boolean contains(final @Nullable Object other) {
      Map.Entry<?, ?> entry = null;
      V value = null;
      if(other instanceof {{ K }}2ObjectMap.Entry) {
        entry = (Map.Entry<?, ?>) other;
        value = {{ K }}2ObjectSyncMapImpl.this.get((({{ K }}2ObjectMap.Entry<?>) entry).get{{ K }}Key());
      } else if(other instanceof Map.Entry) {
        entry = (Map.Entry<?, ?>) other;
        value = {{ K }}2ObjectSyncMapImpl.this.get(entry.getKey());
      }
      return value != null && Objects.equals(value, entry.getValue());
    }

    @Override
    public boolean add(final @NotNull {{ K }}2ObjectMap.Entry<V> entry) {
      requireNonNull(entry, "entry");
      return {{ K }}2ObjectSyncMapImpl.this.put(entry.get{{ K }}Key(), entry.getValue()) == null;
    }

    @Override
    public boolean remove(final @Nullable Object entry) {
      final Map.Entry<?, ?> current;
      if(entry instanceof {{ K }}2ObjectMap.Entry) {
        current = (Map.Entry<?, ?>) entry;
        return {{ K }}2ObjectSyncMapImpl.this.remove((({{ K }}2ObjectMap.Entry<?>) entry).get{{ K }}Key(), current.getValue());
      } else if(entry instanceof Map.Entry) {
        current = (Map.Entry<?, ?>) entry;
        return {{ K }}2ObjectSyncMapImpl.this.remove(current.getKey(), current.getValue());
      }
      return false;
    }

    @Override
    public void clear() {
      {{ K }}2ObjectSyncMapImpl.this.clear();
    }

    @Override
    public @NotNull ObjectIterator<{{ K }}2ObjectMap.Entry<V>> iterator() {
      return new EntryIterator({{ K }}2ObjectSyncMapImpl.this.promote().{{ k }}2ObjectEntrySet().iterator());
    }
  }

  /* package */ final class EntryIterator implements ObjectIterator<{{ K }}2ObjectMap.Entry<V>> {
    private final ObjectIterator<{{ K }}2ObjectMap.Entry<{{ K }}2ObjectExpungingValue<V>>> backingIterator;
    private {{ K }}2ObjectMap.Entry<V> next;
    private {{ K }}2ObjectMap.Entry<V> current;

    /* package */ EntryIterator(final @NotNull ObjectIterator<{{ K }}2ObjectMap.Entry<{{ K }}2ObjectExpungingValue<V>>> backingIterator) {
      this.backingIterator = backingIterator;
      this.advance();
    }

    @Override
    public boolean hasNext() {
      return this.next != null;
    }

    @Override
    public @NotNull {{ K }}2ObjectMap.Entry<V> next() {
      if((this.current = this.next) == null) throw new NoSuchElementException();
      this.advance();
      return this.current;
    }

    @Override
    public void remove() {
      if(this.current == null) throw new IllegalStateException();
      {{ K }}2ObjectSyncMapImpl.this.remove(this.current.get{{ K }}Key());
      this.current = null;
    }

    private void advance() {
      this.next = null;
      while(this.backingIterator.hasNext()) {
        final {{ K }}2ObjectMap.Entry<{{ K }}2ObjectExpungingValue<V>> entry;
        if(!(entry = this.backingIterator.next()).getValue().empty()) {
          this.next = new EntryImpl(entry.get{{ K }}Key());
          return;
        }
      }
    }
  }
}
